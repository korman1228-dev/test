<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>1v1 Tetris Rounded Board with Ghost Piece</title>
<style>
  body {
    background: white;
    display: flex;
    justify-content: center;
    margin-top: 20px;
    font-family: Arial, sans-serif;
  }
  canvas {
    border: 0px; /* 외곽선 제거, 직접 둥근 보드 그릴 예정 */
  }
</style>
</head>
<body>

<canvas id="game" width="650" height="620"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const SCALE = 20;
const COLS = 10;
const ROWS = 20;

ctx.scale(SCALE, SCALE);

const COLORS_P1 = [null, "#4aa3ff","#357edd","#5fa8ff","#7fbfff","#4acbff","#6a8dff","#3b6cff"];
const COLORS_P2 = [null, "#ff4a4a","#dd3535","#ff6a5f","#ff7f7f","#ff4acb","#c86aff","#ff3b3b"];

const SHAPES = [
  [],
  [[1,1,1,1]],
  [[2,0,0],[2,2,2]],
  [[0,0,3],[3,3,3]],
  [[4,4],[4,4]],
  [[0,5,5],[5,5,0]],
  [[0,6,0],[6,6,6]],
  [[7,7,0],[0,7,7]]
];

function matrix(w,h){ return Array.from({length:h},()=>Array(w).fill(0)); }

function createPlayer(offsetX, colors, name){
  return {
    arena: matrix(COLS, ROWS),
    pos:{x:0,y:0},
    matrix:null,
    next:null,
    score:0,
    best:0,
    shake:0,
    offsetX,
    colors,
    name,
    alive:true
  };
}

const p1 = createPlayer(0, COLORS_P1, "P1");
const p2 = createPlayer(16, COLORS_P2, "P2");

let gameOver=false;
let winner=null;

function drawMatrix(mat, offset, ox, colors){
  mat.forEach((row,y)=>{
    row.forEach((v,x)=>{
      if(v){
        ctx.fillStyle = colors[v];
        ctx.fillRect(x+offset.x+ox, y+offset.y, 1, 1);
        ctx.strokeStyle="black";
        ctx.lineWidth=0.05;
        ctx.strokeRect(x+offset.x+ox, y+offset.y, 1, 1);
      }
    });
  });
}

function collide(p){
  for(let y=0;y<p.matrix.length;y++){
    for(let x=0;x<p.matrix[y].length;x++){
      if(p.matrix[y][x] && (p.arena[y+p.pos.y]?.[x+p.pos.x] ?? 1)) return true;
    }
  }
  return false;
}

function merge(p){
  p.matrix.forEach((row,y)=>{
    row.forEach((v,x)=>{
      if(v) p.arena[y+p.pos.y][x+p.pos.x] = v;
    });
  });
}

function rotate(mat){ return mat[0].map((_,i)=>mat.map(r=>r[i]).reverse()); }

function sweep(p){
  let lines=0;
  for(let y=p.arena.length-1;y>=0;y--){
    if(p.arena[y].every(v=>v)){
      p.arena.splice(y,1);
      p.arena.unshift(Array(COLS).fill(0));
      lines++;
      y++;
    }
  }
  if(lines){
    p.score += lines*10;
    p.best = Math.max(p.score,p.best);
    p.shake = 8;
  }
}

function randomPiece(){ return SHAPES[Math.floor(Math.random()*7)+1]; }

function resetPlayer(p){
  p.matrix = p.next || randomPiece();
  p.next = randomPiece();
  p.pos.y=0;
  p.pos.x=(COLS/2|0)-(p.matrix[0].length/2|0);
  if(collide(p)){
    p.alive=false;
    gameOver=true;
    winner=(p===p1)?p2:p1;
  }
}

function drop(p){
  if(!p.alive || gameOver) return;
  p.pos.y++;
  if(collide(p)){
    p.pos.y--;
    merge(p);
    sweep(p);
    resetPlayer(p);
  }
}

function hardDrop(p){
  if(!p.alive || gameOver) return;
  while(!collide(p)) p.pos.y++;
  p.pos.y--;
  merge(p);
  sweep(p);
  resetPlayer(p);
}

// 고스트 블록 그리기 (하드드랍 위치 표시)
function drawGhost(p, ox){
  const ghostMatrix = p.matrix;
  let ghostPos = {x: p.pos.x, y: p.pos.y};

  while(!collide({...p, pos:{x:ghostPos.x, y:ghostPos.y+1}, matrix:ghostMatrix})){
    ghostPos.y++;
  }

  ghostMatrix.forEach((row,y)=>{
    row.forEach((v,x)=>{
      if(v){
        ctx.fillStyle = p.colors[v] + "88"; // 반투명
        ctx.fillRect(x + ghostPos.x + ox, y + ghostPos.y, 1, 1);
      }
    });
  });
}

document.addEventListener("keydown", e => {
  if (gameOver && e.key.toLowerCase() === "r") location.reload();

  if (!gameOver) {
    // P1: WASD + Shift
    if (e.key === "a") { p1.pos.x--; if (collide(p1)) p1.pos.x++; }
    if (e.key === "d") { p1.pos.x++; if (collide(p1)) p1.pos.x--; }
    if (e.key === "s") drop(p1);
    if (e.key === "w") { const m = p1.matrix; p1.matrix = rotate(m); if (collide(p1)) p1.matrix = m; }
    if (e.key === "Shift") hardDrop(p1);

    // P2: 방향키 + /
    if (e.key === "ArrowLeft") { p2.pos.x--; if (collide(p2)) p2.pos.x++; }
    if (e.key === "ArrowRight") { p2.pos.x++; if (collide(p2)) p2.pos.x--; }
    if (e.key === "ArrowDown") drop(p2);
    if (e.key === "ArrowUp") { const m = p2.matrix; p2.matrix = rotate(m); if (collide(p2)) p2.matrix = m; }
    if (e.key === "/") hardDrop(p2);
  }
});

// 둥근 사각형 보드 그리기
function drawBoardOutline(xOffset){
  const radius = 0.3;
  ctx.strokeStyle = "black";
  ctx.lineWidth = 0.1;
  ctx.beginPath();
  ctx.moveTo(xOffset+radius, 0);
  ctx.lineTo(xOffset+COLS-radius,0);
  ctx.quadraticCurveTo(xOffset+COLS,0,xOffset+COLS,radius);
  ctx.lineTo(xOffset+COLS,ROWS-radius);
  ctx.quadraticCurveTo(xOffset+COLS,ROWS,xOffset+COLS-radius,ROWS);
  ctx.lineTo(xOffset+radius,ROWS);
  ctx.quadraticCurveTo(xOffset,ROWS,xOffset,ROWS-radius);
  ctx.lineTo(xOffset, radius);
  ctx.quadraticCurveTo(xOffset,0,xOffset+radius,0);
  ctx.stroke();
}

function drawUI(p, ox){
  ctx.fillStyle = p.colors[1];
  ctx.font="1px Arial";
  ctx.fillText(p.name, ox,1);
  ctx.fillText("SCORE: "+p.score, ox,2);
  ctx.fillText("BEST: "+p.best, ox,3);
  ctx.fillText("NEXT", ox+11,2);
  drawMatrix(p.next,{x:ox+11,y:2.5},0,p.colors);
}

let last=0, dropCounter=0;
function update(t=0){
  const delta=t-last; last=t;
  dropCounter+=delta;
  if(dropCounter>500){ drop(p1); drop(p2); dropCounter=0; }

  ctx.clearRect(0,0,canvas.width,canvas.height);

  [p1,p2].forEach(p=>{
    ctx.save();
    if(p.shake>0){ ctx.translate((Math.random()-0.5)*0.2,(Math.random()-0.5)*0.2); p.shake--; }

    // 고스트 블록 먼저
    drawGhost(p, p.offsetX);

    drawMatrix(p.arena,{x:0,y:0},p.offsetX,p.colors);
    drawMatrix(p.matrix,p.pos,p.offsetX,p.colors);
    drawBoardOutline(p.offsetX);
    ctx.restore();
  });

  drawUI(p1,0);
  drawUI(p2,16);

  if(gameOver){
    ctx.fillStyle="black";
    ctx.font="2px Arial";
    ctx.fillText(winner.name+" WINS!",6.5,10);
    ctx.font="1px Arial";
    ctx.fillText("Press R to Restart",6,12);
  }

  requestAnimationFrame(update);
}

p1.next=randomPiece(); p2.next=randomPiece();
resetPlayer(p1); resetPlayer(p2);
update();
</script>

</body>
</html>
